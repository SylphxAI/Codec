/**
 * ASS/SSA subtitle encoder
 * Generates Advanced SubStation Alpha files
 */

import { formatAssTime } from './decoder'
import {
	DEFAULT_STYLE,
	type AssDialogue,
	type AssFile,
	type AssFormat,
	type AssScriptInfo,
	type AssStyle,
} from './types'

/**
 * Encode ASS file
 */
export function encodeAss(file: AssFile): string {
	const lines: string[] = []

	// Script Info section
	lines.push('[Script Info]')
	lines.push('; Script generated by mconv')
	encodeScriptInfo(file.scriptInfo, file.format, lines)
	lines.push('')

	// Styles section
	if (file.format === 'ass') {
		lines.push('[V4+ Styles]')
		lines.push('Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding')
	} else {
		lines.push('[V4 Styles]')
		lines.push('Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding')
	}

	for (const style of file.styles) {
		lines.push(encodeStyle(style, file.format))
	}
	lines.push('')

	// Events section
	lines.push('[Events]')
	lines.push('Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text')

	for (const comment of file.comments) {
		lines.push(`Comment: ${comment.layer},${comment.start},${comment.end},${comment.style},${comment.name},${comment.marginL},${comment.marginR},${comment.marginV},${comment.effect},${comment.text}`)
	}

	for (const dialogue of file.dialogues) {
		lines.push(encodeDialogue(dialogue))
	}
	lines.push('')

	// Fonts section (if present)
	if (file.fonts && file.fonts.length > 0) {
		lines.push('[Fonts]')
		for (const font of file.fonts) {
			lines.push(font)
		}
		lines.push('')
	}

	// Graphics section (if present)
	if (file.graphics && file.graphics.length > 0) {
		lines.push('[Graphics]')
		for (const graphic of file.graphics) {
			lines.push(graphic)
		}
		lines.push('')
	}

	return lines.join('\n')
}

/**
 * Create a basic ASS file from dialogues
 */
export function createAss(
	dialogues: Array<{
		start: number
		end: number
		text: string
		style?: string
		name?: string
	}>,
	options: {
		title?: string
		resX?: number
		resY?: number
		styles?: AssStyle[]
	} = {}
): string {
	const file: AssFile = {
		format: 'ass',
		scriptInfo: {
			title: options.title || 'Untitled',
			scriptType: 'v4.00+',
			playResX: options.resX || 1920,
			playResY: options.resY || 1080,
			wrapStyle: 0,
			scaledBorderAndShadow: true,
		},
		styles: options.styles || [DEFAULT_STYLE],
		dialogues: dialogues.map((d, i) => ({
			layer: 0,
			start: formatAssTime(d.start),
			end: formatAssTime(d.end),
			style: d.style || 'Default',
			name: d.name || '',
			marginL: 0,
			marginR: 0,
			marginV: 0,
			effect: '',
			text: d.text,
			startTime: d.start,
			endTime: d.end,
		})),
		comments: [],
	}

	return encodeAss(file)
}

/**
 * Encode Script Info section
 */
function encodeScriptInfo(info: AssScriptInfo, format: AssFormat, lines: string[]): void {
	if (info.title) lines.push(`Title: ${info.title}`)
	if (info.originalScript) lines.push(`Original Script: ${info.originalScript}`)
	if (info.originalTranslation) lines.push(`Original Translation: ${info.originalTranslation}`)
	if (info.originalEditing) lines.push(`Original Editing: ${info.originalEditing}`)
	if (info.originalTiming) lines.push(`Original Timing: ${info.originalTiming}`)
	if (info.scriptUpdatedBy) lines.push(`Script Updated By: ${info.scriptUpdatedBy}`)
	if (info.updateDetails) lines.push(`Update Details: ${info.updateDetails}`)

	// Script type
	if (format === 'ass') {
		lines.push('ScriptType: v4.00+')
	} else {
		lines.push('ScriptType: v4.00')
	}

	if (info.collisions) lines.push(`Collisions: ${info.collisions}`)
	if (info.playResX) lines.push(`PlayResX: ${info.playResX}`)
	if (info.playResY) lines.push(`PlayResY: ${info.playResY}`)
	if (info.playDepth) lines.push(`PlayDepth: ${info.playDepth}`)
	if (info.timer !== undefined) lines.push(`Timer: ${info.timer.toFixed(4)}`)
	if (info.wrapStyle !== undefined) lines.push(`WrapStyle: ${info.wrapStyle}`)
	if (info.scaledBorderAndShadow !== undefined) {
		lines.push(`ScaledBorderAndShadow: ${info.scaledBorderAndShadow ? 'yes' : 'no'}`)
	}
}

/**
 * Encode Style line
 */
function encodeStyle(style: AssStyle, format: AssFormat): string {
	if (format === 'ass') {
		return `Style: ${style.name},${style.fontName},${style.fontSize},${style.primaryColor},${style.secondaryColor},${style.outlineColor},${style.backColor},${style.bold ? -1 : 0},${style.italic ? -1 : 0},${style.underline ? -1 : 0},${style.strikeOut ? -1 : 0},${style.scaleX},${style.scaleY},${style.spacing},${style.angle},${style.borderStyle},${style.outline},${style.shadow},${style.alignment},${style.marginL},${style.marginR},${style.marginV},${style.encoding}`
	} else {
		// SSA format (fewer fields)
		return `Style: ${style.name},${style.fontName},${style.fontSize},${style.primaryColor},${style.secondaryColor},${style.outlineColor},${style.backColor},${style.bold ? -1 : 0},${style.italic ? -1 : 0},${style.borderStyle},${style.outline},${style.shadow},${style.alignment},${style.marginL},${style.marginR},${style.marginV},0,${style.encoding}`
	}
}

/**
 * Encode Dialogue line
 */
function encodeDialogue(dialogue: AssDialogue): string {
	return `Dialogue: ${dialogue.layer},${dialogue.start},${dialogue.end},${dialogue.style},${dialogue.name},${dialogue.marginL},${dialogue.marginR},${dialogue.marginV},${dialogue.effect},${dialogue.text}`
}

/**
 * Convert SRT to ASS
 */
export function srtToAss(srtContent: string, options: { title?: string } = {}): string {
	// Import SRT decoder
	const { decodeSrt } = require('../subtitle/decoder')
	const srt = decodeSrt(srtContent)

	const dialogues = srt.cues.map((cue: { startTime: number; endTime: number; text: string }) => ({
		start: cue.startTime,
		end: cue.endTime,
		text: cue.text.replace(/\n/g, '\\N'), // Convert line breaks
	}))

	return createAss(dialogues, { title: options.title })
}

/**
 * Convert VTT to ASS
 */
export function vttToAss(vttContent: string, options: { title?: string } = {}): string {
	// Import VTT decoder
	const { decodeVtt } = require('../subtitle/decoder')
	const vtt = decodeVtt(vttContent)

	const dialogues = vtt.cues.map((cue: { startTime: number; endTime: number; text: string }) => ({
		start: cue.startTime,
		end: cue.endTime,
		text: cue.text.replace(/\n/g, '\\N'), // Convert line breaks
	}))

	return createAss(dialogues, { title: options.title })
}

/**
 * Convert ASS to SRT
 */
export function assToSrt(assContent: string): string {
	const { decodeAss } = require('./decoder')
	const { encodeSrt } = require('../subtitle/encoder')

	const ass = decodeAss(assContent)

	const cues = ass.dialogues.map((d: AssDialogue, i: number) => ({
		index: i + 1,
		startTime: d.startTime || 0,
		endTime: d.endTime || 0,
		text: stripAssTags(d.text).replace(/\\N/gi, '\n'),
	}))

	return encodeSrt(cues)
}

/**
 * Convert ASS to VTT
 */
export function assToVtt(assContent: string): string {
	const { decodeAss } = require('./decoder')
	const { encodeVtt } = require('../subtitle/encoder')

	const ass = decodeAss(assContent)

	const cues = ass.dialogues.map((d: AssDialogue) => ({
		startTime: d.startTime || 0,
		endTime: d.endTime || 0,
		text: stripAssTags(d.text).replace(/\\N/gi, '\n'),
	}))

	return encodeVtt(cues)
}

/**
 * Strip ASS override tags from text
 */
export function stripAssTags(text: string): string {
	// Remove override blocks {...}
	return text.replace(/\{[^}]*\}/g, '')
}

/**
 * Common ASS override tags
 */
export const AssTags = {
	// Style overrides
	bold: (on: boolean) => `{\\b${on ? 1 : 0}}`,
	italic: (on: boolean) => `{\\i${on ? 1 : 0}}`,
	underline: (on: boolean) => `{\\u${on ? 1 : 0}}`,
	strikeout: (on: boolean) => `{\\s${on ? 1 : 0}}`,

	// Font
	fontName: (name: string) => `{\\fn${name}}`,
	fontSize: (size: number) => `{\\fs${size}}`,

	// Colors (ASS format: &HAABBGGRR)
	color: (color: string) => `{\\c${color}}`,
	primaryColor: (color: string) => `{\\1c${color}}`,
	secondaryColor: (color: string) => `{\\2c${color}}`,
	outlineColor: (color: string) => `{\\3c${color}}`,
	shadowColor: (color: string) => `{\\4c${color}}`,

	// Alpha
	alpha: (value: number) => `{\\alpha&H${value.toString(16).padStart(2, '0').toUpperCase()}&}`,

	// Position
	position: (x: number, y: number) => `{\\pos(${x},${y})}`,
	move: (x1: number, y1: number, x2: number, y2: number) => `{\\move(${x1},${y1},${x2},${y2})}`,
	alignment: (align: number) => `{\\an${align}}`,

	// Animation
	fade: (fadeIn: number, fadeOut: number) => `{\\fad(${fadeIn},${fadeOut})}`,
	fadeComplex: (a1: number, a2: number, a3: number, t1: number, t2: number, t3: number, t4: number) =>
		`{\\fade(${a1},${a2},${a3},${t1},${t2},${t3},${t4})}`,

	// Transform
	scale: (x: number, y?: number) => y !== undefined ? `{\\fscx${x}\\fscy${y}}` : `{\\fsc${x}}`,
	rotation: (degrees: number) => `{\\frz${degrees}}`,

	// Effects
	blur: (strength: number) => `{\\blur${strength}}`,
	border: (size: number) => `{\\bord${size}}`,
	shadow: (depth: number) => `{\\shad${depth}}`,

	// Line break
	lineBreak: '\\N',
	softBreak: '\\n',
}
